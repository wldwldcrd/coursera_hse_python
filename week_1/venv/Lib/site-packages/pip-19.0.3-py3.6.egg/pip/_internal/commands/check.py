(node-list-empty? next)
	(empty-node-list)
	(if (chunk? next)
	    (if (navigate-to? next)
		next
		(next-chunk-element next))
	    (next-chunk-element next)))))

(define (abs-next-peer-chunk-element #!optional (elem (current-node)))
  (let* ((fsibling (if (node-list-empty? (follow elem))
		       (empty-node-list)
		       (node-list-first (follow elem)))))
    (if (node-list-empty? fsibling)
	(if (node-list-empty? (parent elem))
	    (empty-node-list)
	    (abs-next-peer-chunk-element (parent elem)))
	fsibling)))

(define (next-peer-chunk-element #!optional (elem (current-node)))
  (let loop ((nd (chunk-level-parent elem)))
    (if (node-list-empty? nd)
	(empty-node-list)
	(if (and (chunk? (abs-next-peer-chunk-element nd))
		 (navigate-to? (abs-next-peer-chunk-element nd)))
	    (abs-next-peer-chunk-element nd)
	    (loop (abs-next-peer-chunk-element nd))))))

(define (next-major-component-chunk-element #!optional (elem (current-node)) (in-chain #f))
  ;; Return the next major component of the document that is not a descendant
  ;; of the starting element.  This is essentially 'next-sibling' but skips
  ;; over things that aren't chunks.
  (if (or (navigate-to? elem) in-chain)
      (if (member (gi elem) (major-component-element-list))
	  (if (node-list-empty? (node-list-first-element (follow elem)))
	      (next-major-component-chunk-element (parent elem))
	      (let ((nd (node-list-first-element (follo